3.1
Duoti du sveiki skaièiai. Surasti jø sumà. Privaloma realizuoti funkcijà int Suma(int a, int b).
#include <iostream>
using namespace std;
int Suma(int a, int b);
int main()
{
	int a, b;
	cin >> a>> b;
	cout << Suma(a, b);
    return 0;
}

int Suma(int a, int b) {
	return (a + b);
}

3.2
Duoti 4 sveiki skaièiai. Surasti jø sumà. Privaloma panaudoti 1 uþd. realizuotà funkcijà int Suma(int a, int b).
#include <iostream>
using namespace std;
int Suma(int a, int b);
int main()
{
	int a, b, c, d;
	cin >> a>> b>> c>>d;
	a = a + c;
	b = b + d;
	cout << Suma(a, b);
    return 0;
}

int Suma(int a, int b) {
	return (a + b);
}

3.3
Duotas sveikas skaièius. Surasti jo reikðmæ dvejetainëje sistemoje. Privaloma realizuoti funkcijà DecToBin(int a)

#include <iostream>
#include <string>
using namespace std;
string DecToBin(int a);
int main()
{
	int num;
	cin >>num ;
	cout<<DecToBin(num);
    return 0;
}

string DecToBin(int a) {
	if (a == 0)
		return to_string(0);
	string r;
	while (a != 0) {
		r = (a % 2 == 0 ? "0" : "1") + r; a /= 2; }
	return r;
}

3.4
Duoti du sveiki skaièiai. Apkeisti jø reikðmes vietomis. Privaloma realizuoti funkcijà Keisti(int &a, int &b).
#include <iostream>
using namespace std;
void Keisti(int &a, int &b);

int main()
{
	int num1, num2;
	cin >> num1>>num2;
    Keisti(num1, num2);
	cout << num1 << endl;
	cout<< num2<<endl;
	return 0;
}

void Keisti(int &a, int &b) {
	int temp;
	temp = a;
	a = b;
	b = temp;
	return;
	
}

3.5
Duotos staèiakampio virðûniø koordinatës. Apskaièiuoti staèiakampio plotà bei perimetrà. Realizuoti funkcijà, kurios áëjimo parametrai – staèiakampio virðûniø koordinatës, iðëjimo parametrai – staèiakampio plotas ir perimetras.
Realûs skaièiai x1,y1,x2,y2,x3,y3,x4,y4 ið intervalo
Iðveskite atsakymà paliekant 5 skaitmenis po kablelio.
#include <iomanip>
#include <cmath>
#include <iostream>
using namespace std;
int main()
{
	double xkord[4], ykord[4];
	
	for (int i = 0; i < 4; i++)
	{
		cin >> xkord[i] >> ykord[i];
	}
	double side[3];
	side[0] = sqrt(pow((xkord[0] - xkord[1]), 2) + pow((ykord[0] - ykord[1]), 2));
	side[1] = sqrt(pow((xkord[0] - xkord[2]), 2) + pow((ykord[0] - ykord[2]), 2));
	side[2] = sqrt(pow((xkord[0] - xkord[3]), 2) + pow((ykord[0] - ykord[3]), 2));
	double A, P;
	if (side[0] >= side[1] && side[0] >= side[2]) {
		A = side[1] * side[2];
		P = side[1] * 2 + side[2] * 2;
	}
	else if (side[1] >= side[0] && side[1] >= side[2]) {
		A = side[0] * side[2];
		P = side[0] * 2 + side[2] * 2;
	}
	else if (side[2] >= side[0] && side[2] >= side[1]) {
		A = side[0] * side[1];
		P = side[0] * 2 + side[1] * 2;
	}
	cout << fixed << setprecision(5) << A << endl;
	cout << fixed << setprecision(5) << P << endl;
	return 0;
}

3.6
Duotas sveikas skaièius. Nustatyti, ar skaièius pirminis. Privaloma realizuoti funkcijà bool IsPrime(long long a).
Jei pirminis iðveskite 1, prieðingu atveju - 0.
#include <iostream>

using namespace std;
bool IsPrime(long long a);

int main()
{
	long long prime;
	
	cin >> prime;
	cout << IsPrime(prime);
    return 0;
}

bool IsPrime(long long a) {
	if (a==1 || a==0) {
		return false;
	}
	for (int i = 2; i <= sqrt(a); i++){
		if (a % i == 0)
			return false;
	}
	return true;
}

3.7
Duota sveikø skaièiø seka. Surikiuoti elementus maþëjimo tvarka. Privaloma realizuoti 3 funkcijas: NuskaitytiSeka(...) SurikiuotiElementus(...) Spausdinti rezultatus(..) Globaliø kintamøjø kurti negalima.
Sekos ilgis iki 10000 elementø, elementai natûralûs skaièiai ið intervalo [0;106].
#include <iostream>
#include <iomanip>
using namespace std;
void NuskaitytiSeka(int a[10001], int n);
void SurikiuotiElementus(int a[10001], int n);
void Spausdintirezultatus(int a[10001], int n);
int main()
{
	int a[10001], n;
	n = 0;
	NuskaitytiSeka(a, n);
	return 0;
}
void NuskaitytiSeka(int a[10001], int n) {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	SurikiuotiElementus(a, n);
}
void SurikiuotiElementus(int a[10001], int n) {
	int t;
	for (int i = 1; i <= n; i++) {

		for (int j = 1; j < n; j++) {
			if (a[j + 1] > a[j]) {
				t = a[j];
				a[j] = a[j + 1];
				a[j + 1] = t;
			}
		}
	}
	Spausdintirezultatus(a, n);
}
void Spausdintirezultatus(int a[10001], int n) {
	for (int i = 1; i <= n; i++) {
		cout << a[i] << endl;
	}
}

3.8
Duotos dvi sveikø skaièiø sekos. Reikia apjungti ðiø sekø elementus ir surikiuoti didëjimo tvarkà. Privaloma naudoti dinaminius masyvus (naudoti rodyklæ ir komandà new).
#include <iostream>
using namespace std;

int main()
{
	int size;
	cin>>size;
	int* array = new int[size];
	for (int i = 0; i < size;i++) {
		cin>>array[i];
	}
	
	int size2;
	cin>>size2;
	int* array2 = new int[size2];
	for (int j = 0; j < size2;j++) {
		cin >> array2[j];
	}
	
	
	int* result = new int[size2+size];
	
	memcpy(result, array, size *sizeof(int));
	memcpy(&result[size], array2, size2 * sizeof(int));
	for (int k = 0; k < size2+size;k++) {
		int smallestIndex=k;
		for (int p = k + 1; p < size2 + size; p++) {
		if (result[p]<result[smallestIndex])
		smallestIndex=p;
		}
		std::swap(result[k], result[smallestIndex]);
		cout << result[k]<<" ";
	}


    return 0;
}

3.9
4 Uþd. funkcijà Keisti(int &a, int &b) perraðyti panaudojus rodykles, t.y. Keisti(int *a, int *b).
#include <iostream>
using namespace std;
void Keisti(int *a, int *b);

int main()
{
	int num1, num2;
	cin >> num1 >> num2;
	Keisti(&num1, &num2);
	cout << num1 << endl;
	cout << num2 << endl;
	
	return 0;
}

void Keisti(int *a, int *b) {
	
	int temp;
	temp = *a;
	*a = *b;
	*b = temp;
	return;

}

3.11
Fibonaèi sekoje pirmi du elementai yra 0 ir 1. Kiekvienas sekantis narys yra lygus dviejø prieð já einanèiø nariø sumai: F(0)?=?0,?F(1)?=?1,?F(n)?=?F(n???1)?+?F(n???2). Apskaièiuokite n-àjá sekos nará panaudodami rekursinæ funkcijà.Skaièius ið intervalo [0;30].
#include <iostream>
#include <fstream>
using namespace std;

int fibo(int n);

int main() {
	int n;
	ifstream listfile("11.in");
	if (listfile.fail()) { cout << "error"; }
	listfile >> n;
	listfile.close();
	ofstream rez("11.out");
	rez << fibo(n);
	rez.close();
	return 0;
}

int fibo(int n)
{
	if (n <= 0 || n>30) { return 0; }
	else if (n == 1 || n == 2) return 1;
	else
		return fibo(n - 1) + fibo(n - 2);
}

3.12
Duotà skaièiø pasukite prieð laikrodþio rodyklæ. Bûtina panaudoti rekursinæ funkcijà.
#include <iostream>
#include <fstream>
using namespace std;
ofstream rezfile("o.txt");
int base = 1;
void rev(int number, int numberAmount) {
	int newnumber;
	newnumber = (number / base) % 10;
	rezfile << newnumber << endl;
	numberAmount--;
	base = base * 10;
	if (numberAmount >= 0) {
		rev(number, numberAmount);
	}
	
}
int main()
{
	int number;
	int numberAmount;
	ifstream listfile("input.txt");
	if (listfile.fail()) { cout << "error"; }
	listfile >> number;
	numberAmount = floor(log10(number));
	rev(number, numberAmount);
	listfile.close();

	
	if (rezfile.fail()) { cout << "errorrez"; }
	rezfile.close();
	return 0;
}

3.13
Dvigubas faktorialas apibrëþiamas taip: f!! = 1 · 3 ·5 · ... · n, kai n nelyginis skaièius ir 2 · 4 · 6 ·... · n, kai n lyginis skaièius Paraðykite rekursinæ funkcijà skaièiaus n dvigubam faktorialui rasti. Sveikas skaièius n (1???n???30).
#include <iostream>
#include <fstream>
using namespace std;


long long int dfact(long long int n) {
	
    //if (n < 0 || n>30) { return 0; }
	if (n == 0 || n == 1) { return 1; }
	//if (n > 1 || n <= 30) 
	else { return n * dfact(n - 2); }
		
	
}
int main()
{
	long long n;
	ifstream listfile("13.txt");
	if (listfile.fail()) { cout << "error"; }
	listfile >> n;
	listfile.close();
	ofstream rezfile("13.out");
	if (rezfile.fail()) { cout << "errorrez"; }
    rezfile<<dfact(n);
	rezfile.close();
	return 0;
}

3.14
Fibonaèi sekoje pirmi du elementai yra 0 ir 1. Kiekvienas sekantis narys yra lygus dviejø prieð já einanèiø nariø sumai: F(0)?=?0,?F(1)?=?1,?F(n)?=?F(n???1)?+?F(n???2). Apskaièiuokite n-àjá sekos nará panaudodami dinaminio programavimo principà. Skaièius ið intervalo [0;80].
#include <iostream>
#include <fstream>
using namespace std;
long long fib[81]; // = { 0 };
long long fibo(int n)
{
	//fib[0] = 0;
	fib[1] = 1;
	fib[2] = 1;
	if (fib[n] == 0)
	{
		for (int j = 3; j <= n; ++j)
		{
			if (fib[n] == 0)
				fib[j] = fib[j - 1] + fib[j - 2];
			else
				continue;
		}
	}
	return fib[n];
	
}

int main() {
	int n;
	ifstream listfile("14.in");
	if (listfile.fail()) { cout << "error"; }
	listfile >> n;
	listfile.close();
	ofstream rez("14.txt");
	rez << fibo(n);
	rez.close();
	return 0;
	
}

3.15
Duota N x N dydþio matrica. Paraðykite funkcijà, kuri pasuktø matricà 90 laipsniø pagal laikrodþio rodyklæ nurodytà kieká kartø k.
#include<iostream>
#include <fstream>
using namespace std;

int main()
{
	ifstream listfile("15.txt");
	if (listfile.fail()) { cout << "error"; }
	long long n;
	long long k;
	int arr[101][101];
	int arr1[101][101];
	listfile >> n;
	listfile >> k;

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				listfile >> arr[i][j];
			}
		}
		listfile.close();
		if (k > 4) {
			while (k > 4) {
				int a;
				k = k - 4;
				a = k;
				if (a == 1) { a = 1; }
				else if (a == 2) { a = 2; }
				else if (a == 3) { a = 3; }
				else if (a == 4) { a = 4; }
			}
		}
				for (int p = 0; p < k; p++)
			{
				for (int i = 0; i < n; i++)
				{
					for (int j = 0; j < n; j++)
					{
						arr1[i][j] = arr[n - j - 1][i];
					}
				}

				for (int i = 0; i < n; i++)
				{
					for (int j = 0; j < n; j++)
					{
						arr[i][j] = arr1[i][j];
						arr1[i][j] = 0;
					}
				}

			}
		

			ofstream rezfile("15");
			if (rezfile.fail()) { cout << "errorrez"; }
			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < n; j++)
					rezfile << arr[i][j] << " ";

				rezfile << "\n";
			}
			rezfile.close();
		
	return 0;
}


3.16
Apskaièiuokite an panaudodami dinaminio programavimo principà.
#include <iostream>
#include <iomanip>
using namespace std;

int power(int x, unsigned int y)
{
	int temp;
	if (y == 0)
		return 1;
	temp = power(x, y / 2);
	if (y % 2 == 0)
		return temp*temp;
	else
		return x*temp*temp;
}
int main()
{
	int a;
	unsigned int n;
	cin >> a;
	cin >> n;
	cout<<power(a, n);

    return 0;
}



//nepirminiu skc kiekis
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
   int N = 0; 
    int count = 0;

	cin >> N;
	
		
	for (int i = 2; i <= N; ++i) {
		bool prime = true;
		for (int j = 2; j*j <= i; ++j) {
			if (i % j == 0)
			{
				prime = false;
				break;

			}
		}
		if (prime) ++count;
	}
		
	

cout << count;

	return 0;
}

-
-
-
3.18
#include <fstream>
#include <vector>
#include <iostream>
using namespace std;
void removeLysve(vector<vector<char>> &matrix, int i, int j);
int Lab3_Problem_18()
{

	int n, m;
	//ifstream in("18.txt");
	//in >> n >> m;
	cin >> n >> m;
	vector<vector<char>> matrix(n, vector<char>(m));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			//in >> matrix[i][j];
			cin >> matrix[i][j];
		}
	}
	//in.close();
	//work
	int vysliuN = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (matrix[i][j] == '#') {
				vysliuN++;
				removeLysve(matrix, i, j);
				//gyvas darbo sekimas
				//for (int iout = 0; iout < n; iout++) {
				//	cout << endl;
				//	for (int jout = 0; jout < m; jout++) {
				//		cout << matrix[iout][jout] << " ";
				//	}
				//}
				//cout << endl;
				//
			}
		}
	}
	cout << vysliuN;
	return 0;
}
void removeLysve(vector<vector<char>> &matrix, int i, int j) {
	matrix[i][j] = '.';
	if ((i - 1) >= 0 && matrix[i - 1][j] == '#') {
		removeLysve(matrix, i - 1, j);
	}
	if ((j + 1) < matrix[i].size() && matrix[i][j + 1] == '#') {
		removeLysve(matrix, i, j + 1);
	}
	if ((i + 1) < matrix.size() && matrix[i + 1][j] == '#') {
		removeLysve(matrix, i + 1, j);
	}
	if ((j - 1) >= 0 && matrix[i][j - 1] == '#') {
		removeLysve(matrix, i, j - 1);
	}
}
-
-
-
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
using namespace std;
void removeFrontZeros(vector<int> &a);
int compare(vector<int> &a, vector<int> &b);
vector<int> subtract(vector<int> a, vector<int> b);
vector<int> addition(std::vector<int> max, std::vector<int> min);
int Lab3_Problem_19()
{
	vector<int> a;
	vector<int> b;
	char temp = '0';
	vector<char> tempCharArray;
	//ifstream in("19.txt");
	//cin.ignore(1);
	while (true) {
		//in.get(temp);
		cin.get(temp);
		if (temp == '\n' || temp == ' ')
			break;
		a.push_back(temp - '0');
	}
	temp = '0';
	while (true) {
		//in.get(temp);
		cin.get(temp);
		if (temp == '\n' || temp == ' ')
			break;
		b.push_back(temp - '0');
	}
	//in.close();
	if (compare(a, b) < 1) {
		a=subtract(a, b);
	}
	else {
		a=addition(a, b);
	}
	removeFrontZeros(a);
	for (int i : a) {
		cout << i;
	}

	return 0;
}
int compare(vector<int> &a, vector<int> &b) {
	if (a.size() > b.size())
		return -1;
	else if (a.size() < b.size())
		return 1;
	else {
		for (int i = 0; i < a.size(); i++) {
			if (a[i] > b[i])
				return -1;
			if (a[i] < b[i])
				return 1;
		}
		return 0;
	}
}
vector<int> subtract(vector<int> a, vector<int> b) {
	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());
	vector<int> c;
	int temp;

	for (int i = 0; i < b.size(); i++) {
		temp = a[i] - b[i];
		if (temp < 0) {
			a[i - 1]--;
			a[i] += 10;
		}
		c.push_back(a[i] - b[i]);
	}
	//reverse(c.begin(), c.end());
	return c;
}
vector<int> addition(vector<int> max, vector<int> min) {
	if (max.size() < min.size()) {
		max.swap(min);
	}
	vector<int> sum;
	int rest = 0;

	for (int i = 0; i < min.size(); i++) {
		int c = min[i] + max[i] + rest;
		sum.push_back(c % 10);
		rest = c / 10;
	}

	for (int i = min.size(); i < max.size(); i++) {
		int c = max[i] + rest;
		sum.push_back(c % 10);
		rest = c / 10;
	}
	while (rest > 0) {
		sum.push_back(rest % 10);
		rest /= 10;
	}
	reverse(sum.begin(), sum.end());
	return sum;
}
void removeFrontZeros(vector<int> &a) {
	while (a[0] == 0 && a.size() > 1) {
		a.erase(a.begin());
	}
}